### LeetCode 1 两数之和 
2018-12-05
代码提交地址 https://leetcode-cn.com/problems/two-sum/submissions/

#### 算法分析

方法1. 暴力查询,整体时间复杂度为$O(n^2)$,空间复杂度为0. 由于python中的list对象实际上是链表，其查询效率为$O(n)$, 即这里的if 语句if num in nums复杂度为$O(n)$,再结合列表循环次数$n$, 整体时间复杂度为$O(n^2)$.

方法2. hash查询,整体时间复杂度为常数级别O(n),空间复杂度为O(n). 使用hash建立 item->index 的映射关系，通过 target-item 反向查找hash是否存在这个index，因为hash的查找时间是O(1)的时间复杂度，所以复杂度如下:

|步骤|时间复杂度|空间复杂度|
| - | :-: | -: | 
|hash映射|n|n|
|反向寻找|1|1|
|总计|n|n|

#### hash表

- hash算法：哈希算法将任意长度的二进制值映射为固定长度的较小二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，经过hash算法计算以后都将产生不同的值。
- hash表：哈希表是根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。简单理解为，一个通过key计算出来的hash值 和 一个存储的对象组成的一个表， 如python中的dict。
- 哈希表存储和查找为什么快：
哈希算法存取之所以快,是因为其直接通过关键字key得到要存取的记录内存存储地址，从而直接对该地址进行读或写。
整个散列过程其实就是两步：
(1) 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
(2) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数， 因此结果当然也是相同的。
简单理解：
将你传入的key通过hash算法运算成一个地址值，就像指针那样，指向内存中的某块区域，存的时候根据该地址值，将value存到这个地址值映射的内存区域里，读的时候同样用key作hash运算得出地址值，直接读取所对应的内存区域中取出结果，所以时间复杂度是O(1)。


