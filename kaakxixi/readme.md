### LeetCode 1 两数之和 
2018-12-05
代码提交地址 https://leetcode-cn.com/problems/two-sum/submissions/

#### 算法分析

方法1. 暴力查询,整体时间复杂度为$$O(n^2)$$,空间复杂度为0. 由于python中的list对象实际上是链表，其查询效率为$O(n)$, 即这里的if 语句if num in nums复杂度为$O(n)$,再结合列表循环次数$n$, 整体时间复杂度为$O(n^2)$.

方法2. hash查询,整体时间复杂度为常数级别O(n),空间复杂度为O(n). 使用hash建立 item->index 的映射关系，通过 target-item 反向查找hash是否存在这个index，因为hash的查找时间是O(1)的时间复杂度，所以复杂度如下:

|步骤|时间复杂度|空间复杂度|
| - | :-: | -: | 
|hash映射|n|n|
|反向寻找|1|1|
|总计|n|n|

#### hash表

- hash算法：哈希算法将任意长度的二进制值映射为固定长度的较小二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，经过hash算法计算以后都将产生不同的值。
- hash表：哈希表是根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。简单理解为，一个通过key计算出来的hash值 和 一个存储的对象组成的一个表， 如python中的dict。
- 哈希表存储和查找为什么快：
哈希算法存取之所以快,是因为其直接通过关键字key得到要存取的记录内存存储地址，从而直接对该地址进行读或写。
整个散列过程其实就是两步：
(1) 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
(2) 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数， 因此结果当然也是相同的。
也就是说，散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用
连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。
简单理解：
将你传入的key通过hash算法运算成一个地址值，就像指针那样，指向内存中的某块区域，存的时候根据该地址值，将value存到这个地址值映射的内存区域里，读的时候同样用key作hash运算得出地址值，直接读取所对应的内存区域中取出结果，所以时间复杂度是O(1)。


#### python中的hash表

- python中的hash表有：字典(dictionary)、集合(set)、计数器(counter)、默认字典Defaut dict)、有序字典(Order dict).
- python的hash表(字典)特点：键值对无序；键和值可以是任意对象；在字典中不能再有序列操作
- python实现hash表：[blog1](https://blog.csdn.net/qq_16000815/article/details/81317314)、[blog2](https://www.cnblogs.com/kumata/p/9157738.html),注意，在python中标准散列机制有hash函数提供，调用一个对象的__hash__方法:
```python
hash(42)
hash("Hello,world!")
```
- python内置数据结构复杂度：[blog](https://blog.csdn.net/u010366748/article/details/51469937)


