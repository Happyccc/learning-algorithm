## LeetCode 50 Pow(x, n)

2018-12-13 leetcode地址 https://leetcode-cn.com/problems/powx-n/submissions/

### 算法分析

方法1. 递归，整体时间复杂度为O(logn),空间复杂度为O(0). 这里利用了分而治之思想：
- 分：根据n为偶数/奇数，求不同的结果
  - n为偶数时，x^n = x^(n/2)·x^(n/2)
  - n为奇数时，x^n = x^(n-1)/2·x^(n-1)/2·x
- 治：分别求出每一子项的结果
- 合并：将每一子项的结果再合并起来，时间复杂度为O(1)
- 递归表达式为T(n) = T(n/2) + O(1) --> T(n) = O(logn)

方法2. 循环，整体时间复杂度为常数级别O(logn),空间复杂度为O(1).循环时用到n = n/2，可知遍历次数为logn.


### 递归
- 递归：基本思想是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。
- 递归三要素：
  1. 明确递归终止条件；
  2. 给出递归终止时的处理办法；
  3. 提取重复的逻辑，缩小问题规模。
- 递归应用场景：
  1. 问题定义是按照递归定义的(Fibonacci、阶乘等)；
  2. 问题的解法是递归的(如汉诺塔问题等)；
  3. 数据结构是递归的(如树、链表的遍历等)。
- 递归算法复杂度：利用分治思想写出递归表达式，根据主定理计算复杂度。
- 递归与循环的理解：递归的精髓在于有去有回，当不满足递归条件的时候，就是开始返回的时候。
- Fibonacci数：斐波那契数列的排列是：0，1，1，2，3，5，8，13，21，34，55，89，144……依次类推下去，你会发现，它后一个数等于前面两个数的和。
```python
def fibonacci(x):
    if x<=1:
        return x
    else:
        return fibonacci(x-2) + fibonacci(x-1)
```
- [参考文献](https://blog.csdn.net/ds1130071727/article/details/80431276)
