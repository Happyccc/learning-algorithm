## LeetCode 148 排序链表

2018-12-12 leetcode地址 https://leetcode-cn.com/problems/sort-list/submissions/

### 算法分析

方法1. 快速排序，整体时间复杂度为O(nlogn),空间复杂度为O(nlogn). 在每次partition过程中，将链表分成left,reference,right三段（left和right可能为空），与参照值reference相同时，全部放入reference这个链表，后续递归该链表。递归过程讨论left和right为空的情况，并连接三条链表.

方法2. 插入排序，整体时间复杂度为常数级别O(n^2),空间复杂度为O(1). 复杂度比较高，最后结果超时。

方法3. 归并排序，整体时间复杂度为常数级别O(nlogn),空间复杂度为O(1). 将链表用快慢指针分成两半，然后两半排序，最后归并，递归实现此过程。由于两个有序链表的合并操作复杂度为O(n)，则T(n) = 2T(n/2) + n --> T(n)=O(nlogn)。


|方法|时间复杂度|空间复杂度|
| - | :-: | -: | 
|快速排序|nlogn|nlogn|
|插入/选择/冒泡排序|n^2|1|
|归并排序|nlogn|1|
|堆排序|nlogn|1|
|希尔排序||1|
|基数排序|d(n+r)|r|

### 排序算法
- 快速排序：又称为划分交换排序，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要笑，然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
- 快排过程：
  1. 选出一个“基准”元素（pivot）；
  2.  重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准大的摆在基准的后面（相同的数，可以放到任意一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  3. 递归（recursive）把小于基准值元素子数列和大于基准值元素的子数列排序。
- 插入排序：通过构建有序序列，对于未排序数据中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后面向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
- [python实现排序算法](https://www.cnblogs.com/reader/p/9561225.html)

